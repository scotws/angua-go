// Opcodes for the 8-bit CPU mode of Angua
// Scot W. Stevenson <scot.stevenson@gmail.com>
// First version: 07. Nov 2018
// First version: 14. Nov 2018

// List of opcode routines for the Emulated (8 bit) mode. These are completely
// brute-forced, and were initially generated by Python scripts (see the tools
// folder).

package emulated

import (
	"fmt"
)

// We keep the opcodes in an array, which will have 256 entries, one for each
// opcode. Note that arrays are mutable in Go, though we can't change the size
// of the array, which we don't care about. This way, we can insert the right
// opcode function when we switch things
var opcodes8 = [256]func(*Emulated){}

// The format for opcodes functions is "opc" followed by the opcode number in
// hex, an underscore, and the mnemonic in SAN notation with the dot converted
// to an underscore.

// opc00_brk realizes the BRK instruction for the emulated CPU. Note it is a
// two-byte instruction because we enforce the status byte.
func opc00_brk(c *Emulated) {
	fmt.Println("DUMMY BRK")
	c.PC += 2
}

func opc01_ora_xi(c *Emulated) {
	fmt.Println("DUMMY ora.xi")
	c.PC += 2
}

func opcE8_inx(c *Emulated) {
	fmt.Println("DUMMY inx")
	c.X += 1
	c.PC += 1
}

//
func init() {
	opcodes8[0x00] = opc00_brk
	opcodes8[0x01] = opc01_ora_xi
	opcodes8[0xE8] = opcE8_inx
}
